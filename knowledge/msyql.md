# 索引
## 索引结构
- B+树
  > 页的默认大小为16KB

  > **非叶子节点中只保存数据key和指针，只有在叶子节点才有数据**

  > 将B+树和链表相结合，在**同层节点与节点之间使用双向链表连接**，在叶子节点的内部数据与数据直接用单向链表连接，这样更**方便于范围查询**

## 索引类型
- 聚簇索引
  > 每个InnoDB表都有一个特殊的索引，称为聚簇索引，用于存储行数据。通常，聚簇索引与主键同义。

  > 聚集索引确定表中数据的物理顺序

- 非聚簇索引
  > 非聚集索引的话其实就是一个普通索引，但是非聚集索引不存储全部数据，只存聚集索引的key

  > 通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为回表！

- 联合索引
  > 遵循最左匹配原则

  > 覆盖索引返回，如果索引中的列数据全部包含要返回的列，则不会再进行回表查询

# 锁
## 锁类型
  - 行锁
  - 行锁
## 如何避免死锁
  1. 合理的设计索引，**区分度高的列放到组合索引前面**，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争
  2. 调整业务逻辑 SQL 执行顺序， **避免 update/delete 长时间持有锁**的 SQL 在事务前面
  3. **避免大事务**，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小
  4. **以固定的顺序访问表和行**。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁
  5. 在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里（运行了 start transaction 或设置了autocommit 等于0）,那么就会锁定所查找到的记录
  6. **尽量按主键/索引去查找记录**，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住
  7. 优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，减少连接的表，**将复杂 SQL 分解**为多个简单的 SQL

# 事务
## undo log
  1. Undo Log用来记录每次修改之前的历史值，配合Redo Log用于故障恢复
  2. 用于事务回滚
  3. 用户MVCC多版本并发控制(读)

## redo log
  1. 保证数据的持久性，也可以用于数据恢复
  2. redo log 是物理日志，记录的是“在某个数据页做了什么修改”，如xx页号，xx偏移量的数据修改为xxx；
  3. Write-Ahead Logging
  4. 循环写

## bin log
  - 主从复制
  - 数据恢复
  - 只有在事务提交时才会记录 biglog

## redo/undo/bin log 总结
  - redo log 用来保证 crash-safe
  - binlog 用来保证可以将数据库状态恢复到任一时刻
  - undo log 是用来保证事务需要回滚时数据状态的回滚和 MVCC 时，记录各版本数据信息。

## 可重复读实现原理
  1. 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
  2. 在事务开启时申请一个事务ID
  3. 每条记录在更新的时候都会同时记录一条 undo log，记录当前的事务ID，记为row tx_id
  4. 在可重复读隔离级别下，一个事务在启动时，InnoDB **会为事务构造一个数组，用来保存这个事务启动瞬间，当前正在”活跃“的所有事务ID**。”活跃“指的是，启动了但还没提交。
  5. **更新数据都是先读后写的，而这个读，只能读当前记录的最新值，称为“当前读“ （current read）。**

# 主从同步
TODO

# 查询优化
TODO

# 其他
1. 导致 MySQL 索引失效的常见场景有以下 6 种
    - 联合索引不满足最左匹配原则  
    - 模糊查询最前面的为不确定匹配字符  
    - 索引列参与了运算
    - 索引列使用了函数
    - 索引列存在类型转换
    - 索引列使用 is not null 查询

2. 为什么建议使用自增主键
   > mysql中每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是主键自增！主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！但是如果主键是无序的或者随机的，那每次的插入可能会**导致原有页频繁的分裂，影响插入效率！降低页的利用率**！这也是为什么在innodb中建议设置主键自增的原因！