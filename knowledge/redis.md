# 数据类型
    String、List、Hash、Set，ZSet

# 原理
## hash
   - 使用ziplist场景（可配置）
     - 所有的键值对的健和值的字符串长度都小于等于64byte（一个英文字母一个字节）
     - 哈希对象保存的键值对数量小于512个
   - 有2个hash表，h[0]/h[1]
## rehash
  - 渐进式（扩、缩容）
  - rehashidx， 记录已完成的rehash进度，当为-1时，表示rehash完成
  - 步骤
    > 1. 为 ht[1] 分配指定空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表
    > 2. 将 rehashidx 设置为0，表示正式开始 rehash
    > 3. 每次对字典执行 增、删、改、查操作时，程序除了执行指定的操作外，还会将 哈希表 ht[0].table中下标为 rehashidx 位置上的所有的键值对 全部迁移到 ht[1].table 上
    > 4. 最后，当 ht[0].used 变为0时，代表所有的键值对都已经从 ht[0] 迁移到 ht[1] 了，释放 ht[0].table， 并且将 ht[0] 设置为 ht[1]，rehashidx 标记为 -1 代表 rehash 结束

## ziplist
  - 每个节点可以保存一个长度受限的字符数组（不以 \0 结尾的 char 数组）或者整数
  - 使用更加 **紧凑的结构** 实现多个元素的 **连续存储**，所以在 **节省内存** 方面比 hashtable 更加优秀
  - 双向链表


# 集群
## 主从模式
### 步骤
  1. 从数据库连接主数据库，**发送 SYNC 命令**
  2. **主数据库**接收到 SYNC 命令后，开始**执行 BGSAVE 命令生成 RDB 文件**并使用缓冲区记录此后执行的所有写命令
  3. 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继**续记录被执行的写命令**
  4. 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照
  5. 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令
  6. 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（从数据库初始化完成）
  7. 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作）
  8. 出现**断开重连情况**，会将断线期间的**命令传给重数据库，增量复制**

### 优缺点
  - 优点
    - master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
    - master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
  - 缺点
    - 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
    - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
    - 难以支持在线扩容，Redis的容量受限于单机配置

## 哨兵模式
> 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障

> 功能
  1. 监控master、slave是否正常运行
  2. 当master出现故障时，能自动将一个slave转换为master
  3. 多个哨兵可以监控同一个Redis，哨兵之间也会自动监控

## cluster模式
- 无中心结构
- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
- 节点的fail是通过集群中超过半数的节点检测失效时才生效
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

### cluster架构及运行机制
1. 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
2. 每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽
3. 集群的每个节点负责一部分hash槽
4. 为了**保证高可用**，Cluster模式也**引入主从复制**模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
5. 其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

# 持久化
> aof 与 rdb，默认情况下，Redis是没有开启AOF的

> 因为 AOF 文件的保存频率通常要高于 RDB 文件保存的频率， 所以一般来说， AOF 文件中的数据会比 RDB 文件中的数据要新

> **支持RDB和AOF的混合方式**，简单来说，内存快照以一定的频率执行，在**两次快照之间，使用 AOF 日志记录这期间的所有命令操作**。

## 恢复
**aof优先于rdb文件**，因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据

## AOF
> 协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的

> **AOF日志采用写后日志，即先写内存，后写日志**

### aof 三个阶段
  1. 命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中
  2. 缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容**追加到服务器的 AOF 缓存**中
  3. 文件写入和保存：AOF 缓存中的内容被**写入到 AOF 文件末尾**，如果设定的 AOF 保存条件被满足的话， fsync 函数或者 fdatasync 函数会被调用，将写入的内容真正地保存到磁盘中 （**宕机是即会存在丢失数据的情形**）

### aof 保存模式
| 模式     | 保存方式                         | 优点                       | 缺点                           | 停机时丢失的数据量                                  |
| -------- | -------------------------------- | -------------------------- | ------------------------------ | --------------------------------------------------- |
| ALWAYS   | 每执行一个命令保存一次           | 可靠性高，数据基本不会丢失 | 每次写命令都要落盘，性能影响大 | 最多只丢失一个命令的数据                            |
| EVERYSEC | 先写入内存缓冲，每一秒钟保存一次 | 性能适中                   | 宕机会丢失部分数据             | 一般情况下不超过 2 秒钟的数据                       |
| NO       | 不保存                           | 性能好                     | 宕机丢失数据多                 | 操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据 |

### aof 重写
> 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积

> 所谓的“重写”其实是一个有歧义的词语， 实际上， **AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值**

> Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的大好
  >> 1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
  >> 2. 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性

> 进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改，Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用

### aof 重写条件
  1. 没有 BGSAVE 命令在进行
  2. 没有 BGREWRITEAOF 在进行
  3. 当前 AOF 文件大小大于 server.aof_rewrite_min_size （默认值为 1 MB）
  4. 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比（默认情况下， 增长百分比为 100%）

## RDB
> RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值
 
> RDB中的核心思路是**写时复制（Copy-on-Write）**，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化

### rdb 保存触发方式
  - 手动触发
    - save
      - 阻塞 Redis 主进程，直到保存完成为止。在主进程阻塞期间，服务器不能处理客户端的任何请求
    - **bgsave** 
      - **fork 出一个子进程，子进程负责调用 rdbSave** ，并在保存完成之后向主进程发送信号，通知保存已完成。因为 rdbSave 在子进程被调用，所以 Redis 服务器在 **BGSAVE 执行期间仍然可以继续处理客户端的请求**
  - 自动触发（4中情况）
    - redis.conf中配置**save m n**，即在**m秒内有n次修改**时，自动触发bgsave生成rdb文件
    - 主从复制时，从节点要从主节点**进行全量复制时也会触发bgsave操作**，生成当时的快照发送到从节点
    - 执行debug reload命令重新加载redis时也会触发bgsave操作
    - 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作


# 其他
## 淘汰策略
   - 不淘汰（默认）
     - 该策略是Redis的默认策略。在这种策略下，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。这种策略不会淘汰数据，所以无法解决缓存污染问题。一般生产环境不建议使用
   - 对设置了过期时间的数据中进行淘汰
     - 随机：volatile-random
     - ttl：volatile-ttl
     - lru：volatile-lru
     - lfu：volatile-lfu
   - 全部数据进行淘汰
     - 同过期淘汰策略
## 缓存问题
### 缓存穿透
   - 描述
     > 缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义

   - 解决方案
    1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截
    2. 从缓存取不到的数据，缓存空值，过期时间设置短，例如1秒
    3. 布隆过滤器

### 缓存击穿
   - 描述
     > 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

   - 解决方案
    1. 设置热点数据永远不过期
    2. 接口限流与熔断，降级
    3. 加互斥锁，同一时间只有一个线程读取相同的key数据

### 缓存雪崩
   - 描述
     > 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库
   
   - 解决方案
     1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
     2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中
     3. 设置热点数据永远不过期

### 分布式锁
> 各种实现方案在极端情况下仍然会存在安全问题或引来性能问题，使用**redis分布式锁并不能100%保证锁的安全性**
    >> - 锁超时，业务处理未完成，但是锁已经过期了
    >> - 主从切换（异步复制延时）时导致是锁失效
    >> - 长时间锁定，程序hang住或崩溃导致性能问题
    >> - **释放锁时需要注意检查是否是当前线程加的锁**（uuid），然后利用lua脚本原子性执行