# 数据类型
    String、List、Hash、Set，ZSet

# 原理
## hash
   - 使用ziplist场景（可配置）
     - 所有的键值对的健和值的字符串长度都小于等于64byte（一个英文字母一个字节）
     - 哈希对象保存的键值对数量小于512个
   - 有2个hash表，h[0]/h[1]
## rehash
  - 渐进式（扩、缩容）
  - rehashidx， 记录已完成的rehash进度，当为-1时，表示rehash完成
  - 步骤
    > 1. 为 ht[1] 分配指定空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表
    > 2. 将 rehashidx 设置为0，表示正式开始 rehash
    > 3. 每次对字典执行 增、删、改、查操作时，程序除了执行指定的操作外，还会将 哈希表 ht[0].table中下标为 rehashidx 位置上的所有的键值对 全部迁移到 ht[1].table 上
    > 4. 最后，当 ht[0].used 变为0时，代表所有的键值对都已经从 ht[0] 迁移到 ht[1] 了，释放 ht[0].table， 并且将 ht[0] 设置为 ht[1]，rehashidx 标记为 -1 代表 rehash 结束

## ziplist
  - 每个节点可以保存一个长度受限的字符数组（不以 \0 结尾的 char 数组）或者整数
  - 使用更加 **紧凑的结构** 实现多个元素的 **连续存储**，所以在 **节省内存** 方面比 hashtable 更加优秀
  - 双向链表


# 集群
## 主从模式
### 步骤
  1. 从数据库连接主数据库，**发送 SYNC 命令**
  2. **主数据库**接收到 SYNC 命令后，开始**执行 BGSAVE 命令生成 RDB 文件**并使用缓冲区记录此后执行的所有写命令
  3. 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继**续记录被执行的写命令**
  4. 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照
  5. 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令
  6. 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（从数据库初始化完成）
  7. 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作）
  8. 出现**断开重连情况**，会将断线期间的**命令传给重数据库，增量复制**

### 优缺点
  - 优点
    - master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
    - master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
  - 缺点
    - 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
    - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
    - 难以支持在线扩容，Redis的容量受限于单机配置

## 哨兵模式
> 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障

> 功能
  1. 监控master、slave是否正常运行
  2. 当master出现故障时，能自动将一个slave转换为master
  3. 多个哨兵可以监控同一个Redis，哨兵之间也会自动监控

## cluster模式
- 无中心结构
- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
- 节点的fail是通过集群中超过半数的节点检测失效时才生效
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

### cluster架构及运行机制
1. 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
2. 每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽
3. 集群的每个节点负责一部分hash槽
4. 为了**保证高可用**，Cluster模式也**引入主从复制**模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
5. 其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

# 持久化

## AOF

## RDB

# 其他
## 过期逐出策略